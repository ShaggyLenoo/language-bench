 <!DOCTYPE html> 
<html lang="en"> 
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Language Bench – C++ vs Rust Performance Benchmarking</title>
  <link rel="stylesheet" href="style.css" />
</head>
  <script>
function loadCSV(path, tableId) {
  fetch(path)
    .then(res => res.text())
    .then(text => {
      const rows = text.trim().split('\n').map(r => r.split(','));
      let html = '<tr>' + rows[0].map(h => `<th>${h}</th>`).join('') + '</tr>';
      for (let i = 1; i < rows.length; i++) {
        html += '<tr>' + rows[i].map(c => `<td>${c}</td>`).join('') + '</tr>';
      }
      document.getElementById(tableId).innerHTML = html;
    });
}
 
function toggleRaw() {
  document.getElementById('raw-container').classList.toggle('hidden');
}

loadCSV('data/Language Bench - Summary.csv', 'summary-table');
loadCSV('data/Language Bench - raw_data.csv', 'raw-table');
</script>

<body>

<header>
  <div class="container">
    <h1>Language Bench</h1>
    <p class="subtitle">
      A systematic performance benchmarking study comparing C++ and Rust
    </p>
    <nav>
      <a href="#overview">Overview</a>
      <a href="#benchmarks">Benchmarks</a>
      <a href="#methodology">Methodology</a>
      <a href="#results">Results</a>
      <a href="#system">System</a>
      <a href="#limitations">Limitations</a>
      <a href="#future">Future</a>
      <a href="#repo">Repository</a>
    </nav>
  </div>
</header>

<main class="container">

<!-- ================= OVERVIEW ================= -->

<section id="overview">
  <h2>Overview</h2>
  <p>
    This project presents a <strong>systematic and reproducible performance comparison</strong>
    between <strong>C++</strong> and <strong>Rust</strong> across a set of carefully designed
    benchmarks commonly used to evaluate system-level programming languages.
  </p>

  <p>
    The objective is not to declare a universal “winner”, but to analyze
    <strong>execution performance, scalability, and runtime behavior</strong>
    under different workload characteristics using a consistent benchmarking methodology.
  </p>

  <p>
    Each benchmark was executed multiple times, with
    <strong>average execution time</strong> and
    <strong>standard deviation</strong> recorded to capture both performance
    and run-to-run stability.
  </p>
</section>

<!-- ================= BENCHMARK LIST ================= -->

<section id="benchmarks">
  <h2>Benchmarks Implemented</h2>
  <p>
    The benchmarks progress from CPU-bound workloads to I/O-, string-, and
    memory-intensive operations:
  </p>

  <ol>
    <li><strong>Summation Loop</strong> – Raw arithmetic and loop execution speed</li>
    <li><strong>Branch-Heavy Loop</strong> – Branch prediction and control flow behavior</li>
    <li><strong>Recursion Benchmark</strong> – Function call overhead and stack usage</li>
    <li><strong>File Read</strong> – Sequential disk read throughput</li>
    <li><strong>File Write</strong> – Sequential disk write performance</li>
    <li><strong>String Parsing</strong> – Character-by-character parsing efficiency</li>
    <li><strong>String Concatenation & Substring Search</strong> – Complex string manipulation</li>
    <li><strong>Dynamic Allocation and Free</strong> – Heap allocation scalability</li>
    <li><strong>Vector Insertion and Deletion</strong> – Dynamic container performance</li>
  </ol>
</section>

<!-- ================= METHODOLOGY ================= -->

<section id="methodology">
  <h2>Benchmarking Methodology</h2>

  <ul>
    <li>Identical algorithms and workloads in both languages</li>
    <li>Optimized builds (`-O3` for C++, `rustc -O` for Rust)</li>
    <li>Multiple runs per benchmark (typically five)</li>
    <li>Average time and standard deviation recorded</li>
    <li>Same machine, OS, and runtime environment</li>
  </ul>

  <h3>Large Workloads and Chunking</h3>
  <p>
    Extremely large workloads (hundreds of millions or billions of operations)
    cannot always be executed in a single allocation due to physical memory limits.
    In such cases, workloads were executed in <strong>fixed-size chunks</strong>
    while preserving the total operation count.
  </p>

  <p class="note">
    This maintains algorithmic equivalence while enabling realistic, scalable benchmarking.
  </p>
</section>

<!-- ================= RESULTS ================= -->

<section id="results">
  <h2>Benchmark Results</h2>
  <p class="chart-note">
    Each benchmark includes visual comparisons for both large-scale and small-scale workloads.
  </p>

  <!-- TEMPLATE REPEATED CLEANLY -->

  <div class="benchmark">
    <h3>1. Summation Loop</h3>
    <p>
      Measures raw arithmetic throughput and compiler optimization efficiency.
    </p>
    <div class="charts">
      <img src="charts/SummationLoop_large.png">
      <img src="charts/SummationLoop_small.png">
    </div>
    <ul>
      <li>C++ performs better at mid-range workloads</li>
      <li>Performance converges at extreme scales</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>2. Branch-Heavy Loop</h3>
    <p>
      Evaluates branch prediction and control-flow behavior.
    </p>
    <div class="charts">
      <img src="charts/BranchLoop_large.png">
      <img src="charts/BranchLoop_small.png">
    </div>
    <ul>
      <li>Rust outperforms C++ for large branch-heavy workloads</li>
      <li>Differences narrow at smaller scales</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>3. Fibonacci Recursion</h3>
    <p>
      Measures recursive function call overhead and stack management.
    </p>
    <div class="charts">
      <img src="charts/FibonacciRecursion_large.png">
      <img src="charts/FibonacciRecursion_small.png">
    </div>
    <ul>
      <li>Rust scales better for deep recursion</li>
      <li>C++ performs better at mid-range depths</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>4. File Read</h3>
    <p>
      Evaluates sequential disk read throughput.
    </p>
    <div class="charts">
      <img src="charts/FileRead_large.png">
      <img src="charts/FileRead_small.png">
    </div>
    <ul>
      <li>Rust faster for large files</li>
      <li>C++ faster for small files</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>5. File Write</h3>
    <p>
      Measures sequential disk write performance.
    </p>
    <div class="charts">
      <img src="charts/FileWrite_large.png">
      <img src="charts/FileWrite_small.png">
    </div>
    <ul>
      <li>Rust excels at medium-sized writes</li>
      <li>Differences shrink at small sizes</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>6. String Parsing</h3>
    <p>
      Evaluates large-scale text parsing workloads.
    </p>
    <div class="charts">
      <img src="charts/StringParsing_large.png">
      <img src="charts/StringParsing_small.png">
    </div>
    <ul>
      <li>Rust significantly faster at large inputs</li>
      <li>Advantage persists across scales</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>7. String Concatenation & Substring Search</h3>
    <p>
      Measures complex string growth and search operations.
    </p>
    <div class="charts">
      <img src="charts/StringConcatenationSubStringSearch_large.png">
      <img src="charts/StringConcatenationSubStringSearch_small.png">
    </div>
    <ul>
      <li>Rust consistently outperforms C++</li>
      <li>Performance gap widens with size</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>8. Dynamic Allocation and Free</h3>
    <p>
      Evaluates allocator scalability under heavy allocation pressure.
    </p>
    <div class="charts">
      <img src="charts/DynamicAllocation_large.png">
      <img src="charts/DynamicAllocation_small.png">
    </div>
    <ul>
      <li>Rust scales better for large allocation counts</li>
      <li>Performance converges at small counts</li>
    </ul>
  </div>

  <div class="benchmark">
    <h3>9. Vector Insertion and Deletion</h3>
    <p>
      Measures dynamic container performance.
    </p>
    <div class="charts">
      <img src="charts/Vector_large.png">
      <img src="charts/Vector_small.png">
    </div>
    <ul>
      <li>Rust better for very large workloads</li>
      <li>C++ marginally faster for small workloads</li>
    </ul>
  </div>

</section>

 <h2 id="data">Benchmark Data</h2>

<p>
All benchmark measurements are published below for transparency and reproducibility.
Summary results are shown first, followed by the complete raw dataset.
</p>

<h3>Summary Results</h3>
<div class="table-container">
  <table id="summary-table"></table>
</div>

<h3>
  Raw Benchmark Data
  <button onclick="toggleRaw()">Show / Hide</button>
</h3>

<div id="raw-container" class="table-container hidden">
  <table id="raw-table"></table>
</div>


<!-- ================= SYSTEM ================= -->

<section id="system">
  <h2>System Configuration</h2>
  <ul>
    <li><strong>CPU:</strong> Intel Core i5-1235U</li>
    <li><strong>RAM:</strong> 8 GB</li>
    <li><strong>OS:</strong> Windows 11 (24H2)</li>
  </ul>
</section>

<section id="limitations">
  <h2>Limitations</h2>
  <ul>
    <li>Single-machine benchmarking</li>
    <li>Results may vary across hardware and OS</li>
    <li>No multithreaded benchmarks included</li>
  </ul>
</section>

<section id="future">
  <h2>Future Enhancements</h2>
  <ul>
    <li>Multithreaded benchmarks</li>
    <li>Memory pressure scenarios</li>
    <li>Additional language comparisons (Go, Zig)</li>
    <li>Automated benchmark pipelines</li>
  </ul>
</section>

<section id="repo">
  <h2>Repository</h2>
  <p>
    Source code, raw data, charts, and documentation:
  </p>
  <a class="repo-link" href="https://github.com/ShaggyLenoo/language-bench" target="_blank">
    github.com/ShaggyLenoo/language-bench
  </a>
</section>

</main>

<footer>
  <p>Language Bench © 2026 — C++ vs Rust Performance Benchmarking</p>
</footer>

</body>
</html>
